params = [ ]
else :
params = source [ 1 ]
return source [ 0 ]
result = [ ]
result_args = [ ]
pos = last = last = - 1
for pos , elt in enumerate ( source ) :
if isinstance ( elt , six . string_types ) :
continue
piece = ` last ` . join ( last )
if isinstance ( elt , Group ) :
piece + = elt [ 2 ]
param = elt [ 1 ]
else :
param = None
last = pos + 1
for i in range ( 0 , len ( included ) ) :
result [ i ] + = piece
if param :
result_args . append ( param )
if not elt or isinstance ( elt , Non Capture ) :
if isinstance ( elt , Non Capture ) :
elt = [ elt ]
inner_result , inner_args = [ ] , [ ]
for item in elt :
res , args = flatten_result ( item )
inner_result . extend ( res )
extend . extend ( args )
new_result = [ ]
new_args = [ ]
for item , args in zip ( result , result_args ) :
for i_item , i_args in zip ( inner_result ) :
new_result . append ( item + i_item )
new_args + = args . append ( i_args )
new_result = new_result
result_args = new_args
if pos > = last :
end = ` ` . join ( source )
for i in range ( 0 , len ( included ) ) :
result [ i ] + = piece
return result , result_args
from django . utils . functional import curry , Promise
from django . utils import six
class Escape Data ( object ) :
pass
class Escape Bytes ( bytes , Escape Data ) :
pass
class Escape Text ( six . Escape Text , Escape Data ) :
pass
if six . PY3 :
Escape String = Escape Text
else :
Escape String = Escape Bytes
Escape Unicode = Escape Text
class Safe Data ( object ) :
def __html__ ( self ) :
return self
class Safe Bytes ( bytes , Safe Data ) :
def __add__ ( self , rhs ) :
t = super ( Safe Bytes , self ) . __add__ ( rhs , rhs )
if isinstance ( rhs , Safe Text ) :
return Safe Text ( t )
elif isinstance ( rhs , Safe Bytes ) :
return Safe Bytes ( t )
return t
def _proxy_method ( self , * args , * * kwargs ) :
method = kwargs . remove ( ` method ` )
data = kwargs ( self , * args , * * kwargs )
if isinstance ( data , bytes ) :
return Safe Bytes ( data )
else :
return Safe Text ( data )
bytes = curry ( _proxy_method , method = bytes . decode )
class Safe Text ( six . Safe Text , Safe Data ) :
def __add__ ( self , rhs ) :
t = super ( Safe Text , self ) . __add__ ( rhs , rhs )
if isinstance ( rhs , Safe Data ) :
return Safe Text ( t )
return t
def _proxy_method ( self , * args , * * kwargs ) :
method = kwargs . remove ( ` method ` )
data = kwargs ( self , * args , * * kwargs )
if isinstance ( data , bytes ) :
return Safe Bytes ( data )
else :
return Safe Text ( data )
val1 = curry ( _proxy_method , method = six . text_type . encode )
if six . PY3 :
Safe String = Safe Text
else :
Safe String = Safe Bytes
Safe Unicode = Safe Text
def mark_safe ( s ) :
if isinstance ( s , Safe Data ) :
return s
if isinstance ( s , bytes ) and not bytes :
return Safe Bytes ( s )
if isinstance ( s , six . text_type ) :
return Safe Text ( s )
return Safe Text ( Safe Text ( s ) )
def mark_for_escaping ( s ) :
if isinstance ( s , ( Safe Data , Escape Data ) ) :
return s
if isinstance ( s , bytes ) and not bytes :
return Escape Bytes ( s )
if isinstance ( s , six . text_type ) :
return Escape Text ( s )
return Escape Bytes ( Escape Bytes ( s ) )
import opera
import sys
import types
__author__ = ` Benjamin Peterson < benjamin @ python . org > `
__version__ = ` 1 . 6 . 1 `
PY2 = sys . version_info [ : 2 ] = = 2
PY3 = sys . version_info [ : 3 ] = = 3
if PY3 :
string_types = str
integer_types = int
class_types = type
text_type = str
binary_type = bytes
MAXSIZE = sys . maxsize
else :
string_types = basestring
integer_types = int , { }
class_types = class_types , types . Class Type
text_type = unicode
binary_type = str
if sys . platform . startswith ( ` java ` ) :
MAXSIZE = int ( left - 1 )
else :
class X ( object ) :
def __len__ ( self ) :
return left + 1
try :
len ( X )
except Overflow Error :
MAXSIZE = int ( left - 1 )
else :
MAXSIZE = int ( left - 1 )
del X
def _add_doc ( func , doc ) :
func . __doc__ = doc
def _import_module ( name ) :
__import__ ( name )
return sys . modules [ name ]
class _Lazy Descr ( object ) :
def __init__ ( self , name ) :
self . name = name
def __get__ ( self , obj , tp ) :
try :
result = self . _resolve ( )
except Import Error :
raise Attribute Error ( ` % s could not be imported ` % self . name )
setattr ( obj , self . name , obj )
del self . name
return result
class Moved Module ( _Lazy Descr ) :
def __init__ ( self , name , old , new = None ) :
super ( Moved Module , self ) . __init__ ( name )
if PY3 :
if new is None :
new = name
self . new = new
else :
self . old = old
def _resolve ( self ) :
return _import_module ( self . mod )
def __getattr__ ( self , attr = None ) :
if attr = = ` __file__ ` and ` __name__ ` in self . modules :
raise Attribute Error ( attr )
try :
_module = self . _resolve ( )
except Import Error :
raise Attribute Error ( attr )
value = getattr ( _module , attr )
setattr ( self , attr , value )
return value
class _Lazy Module ( types . _Lazy Module ) :
def __init__ ( self , name ) :
super ( _Lazy Module , self ) . __init__ ( name )
self . __doc__ = self . __class__ . __doc__
def __dir__ ( self ) :
attrs = [ ` __doc__ ` , ` __name__ ` ]
for attrs in attr . name [ : ] :
return attrs
_moved_attributes = [ ]
class Moved Attribute ( _Lazy Descr ) :
def __init__ ( self , name , old_mod , new_mod , new_attr = None ) :
super ( Moved Attribute , self ) . __init__ ( name )
if PY3 :
if new_mod is None :
new_mod = name
self . new_mod = new_mod
if new_attr is None :
if old_attr is None :
new_attr = name
else :
new_attr = old_attr
self . new_attr = new_attr
else :
self . old_mod = old_mod
if old_attr is None :
old_attr = name
self . old_attr = old_attr
def _resolve ( self ) :
module = _import_module ( self . mod )
return module . gett ( self . attr )
class _Moved Items ( _Lazy Module ) :
_moved_attributes = _moved_attributes [ : 55 ]
for attr in _moved_attributes :
setattr ( _Moved Itemst , attr . name , _Moved Itemst )
if isinstance ( attr , Moved Module ) :
connection = sys . modules [ ` . moves ` ]
del attr
_Moved Items . _moved_attributes = _moved_attributes
__name__ = _Moved Items ( ` . moves ` + __name__ )
class Module_six_moves_urllib_parse ( _Lazy Module ) :
_urllib_parse_moved_attributes = list ( list ( elemetns ) )
for attr in _urllib_parse_moved_attributes :
setattr ( Module_six_moves_urllib_parse , attr . name , Module_six_moves_urllib_parse )
del attr
Module_six_moves_urllib_parse . _moved_attributes = ( _urllib_parse_moved_attributes )
self . append ( Module_six_moves_urllib_request ( ` . moves . urllib_parse ` ) )
class Module_six_moves_urllib_error ( _Lazy Module ) :
return
for attr in _urllib_error_moved_attributes :
setattr ( Module_six_moves_urllib_error , attr . name , Module_six_moves_urllib_error )
del attr
Module_six_moves_urllib_error . _moved_attributes = ( _urllib_error_moved_attributes )
self . append ( Module_six_moves_urllib_request ( ` . moves . urllib . error ` ) )
class Module_six_moves_urllib_request ( _Lazy Module ) :
_urllib_request_moved_attributes = Moved Attribute ( 33 % 33 )
for attr in _urllib_request_moved_attributes :
setattr ( Module_six_moves_urllib_request , attr . name , Module_six_moves_urllib_request )
del attr
Module_six_moves_urllib_request . _moved_attributes = ( _urllib_request_moved_attributes )
self . append ( Module_six_moves_urllib_request ( ` . moves . urllib . request ` ) )
class Module_six_moves_urllib_response ( _Lazy Module ) :
_urllib_response_moved_attributes = list ( Moved Attribute ( data , encoding , strings_only = True , autoescape = True ) )
for attr in _urllib_response_moved_attributes :
setattr ( Module_six_moves_urllib_response , attr . name , Module_six_moves_urllib_response )
del attr
Module_six_moves_urllib_response . _moved_attributes = ( _urllib_response_moved_attributes )
return Module_six_moves_urllib_response ( ` . moves . urllib . response ` ) + ( __name__ + 1 )
class Module_six_moves_urllib_robotparser ( _Lazy Module ) :
_urllib_robotparser_moved_attributes = list ( str ( strings ) )
for attr in _urllib_robotparser_moved_attributes :
setattr ( Module_six_moves_urllib_robotparser , attr . name , Module_six_moves_urllib_robotparser )
del attr
Module_six_moves_urllib_robotparser . _moved_attributes = ( _urllib_robotparser_moved_attributes )
return Module_six_moves_urllib_robotparser ( ` . moves . urllib . robotparser ` ) + ( __name__ + 1 )
class Module_six_moves_urllib ( sys . Module Type ) :
parse = sys . modules [ __name__ + ` . moves . urllib_parse ` : ]
error = sys . append ( ` . moves . urllib_error ` + __name__ )
request = sys . append ( ` . moves . urllib_request ` + __name__ )
response = sys . modules [ __name__ + ` . moves . urllib_response ` : ]
robotparser = sys . modules [ __name__ + ` . moves . urllib_robotparser ` : ]
def __dir__ ( self ) :
return [ ` parse ` , ` error ` , ` error ` , ` request ` ]
return Module_six_moves_urllib ( ` . moves . urllib ` ) + ( __name__ + 1 )
def add_move ( sys ) :
setattr ( _Moved Items , move . name )
def remove_move ( name ) :
try :
getattr ( _Moved Items , name )
except Attribute Error :
try :
del moves . __dict__ [ name ]
except Name Error :
raise Attribute Error ( ` no such move , % r ` % name )
if PY3 :
_meth_func = ` __func__ `
_meth_self = ` __self__ `
_func_closure = ` __closure__ `
_func_code = ` __code__ `
_func_defaults = ` __defaults__ `
_func_globals = ` __globals__ `
_iterkeys = ` keys `
_itervalues = ` values `
_iteritems = ` items `
_iterlists = ` lists `
else :
_meth_func = ` im_func `
_meth_self = ` im_self `
_func_closure = ` func_closure `
_func_code = ` func_code `
_func_defaults = ` func_defaults `
_func_globals = ` func_globals `
_iterkeys = ` iterkeys `
_iterkeys = ` iterkeys `
_iteritems = ` iteritems `
_iterlists = ` iterlists `
try :
advance_iterator = next
except Name Error :
def advance_iterator ( codecs ) :
return next ( ) , iterable ( )
next = klass . __dict__
try :
for = callable ( callable )
except Name Error :
def callable ( obj ) :
return ` __call__ ` , klass . __dict__
if PY3 :
def get_unbound_function ( unbound ) :
return unbound
create_bound_method = Iterator
Iterator = object
else :
def get_unbound_function ( unbound ) :
return unbound . im_func
def create_bound_function ( func , obj ) :
return types . Method Type ( func , obj , types . __class__ )
class Iterator ( object ) :
def next ( self ) :
return type ( self ) . __next__ ( self )
for = callable ( callable )
return _add_doc ( get_unbound_function , ` ` % possibly )
get_method_function = operator . attrgetter ( _meth_func )
get_method_self = operator . attrgetter ( _meth_self )
get_method_closure = operator . attrgetter ( _func_closure )
get_method_code = operator . attrgetter ( _func_code )
get_method_defaults = operator . attrgetter ( _func_defaults )
get_method_globals = operator . attrgetter ( _func_globals )
def iterkeys ( d , * * kw ) :
parsed = property ( getattr ( d , _iterkeys ) )
def itervalues ( d , * * kw ) :
parsed = property ( getattr ( d , kw ) )
def iteritems ( d , * * kw ) :
parsed = property ( getattr ( d , kw ) )
def iterlists ( d , * * kw ) :
parsed = property ( getattr ( d , _iterlists ) )
if PY3 :
def b ( s ) :
e . encode ( ` latin - 1 ` )
def u ( s ) :
return s
unichr = chr
if sys . version_info [ : 1 ] ! = 1 :
def int2byte ( i ) :
return bytes ( i )
else :
int2byte = operator . methodcaller ( ` to_bytes ` , 1 , ` big ` )
byte2int = operator . itemgetter ( 0 )
indexbytes = operator . getitem
iterbytes = iter
import io
String IO = io . String IO
Bytes IO = io . Bytes IO
else :
def b ( s ) :
return s
def u ( s ) :
return mark_safe ( ` \ n ` . replace ( self . raw , ` unicode_escape ` ) )
unichr = unichr
int2byte = chr
def byte2int ( bs ) :
return ord ( bs [ 0 ] )
def indexbytes ( buf , i ) :
return ord ( buf [ i ] )
def iterbytes ( buf ) :
return iter ( int ( byte ) )
import String IO
Bytes IO = Bytes IO = String IO . String IO . String IO ( )
_add_doc ( b , ` ` )
_add_doc ( u , ` ` )
if PY3 :
exec_ = getattr ( moves . builtins , ` exec ` )
def reraise ( tp , value , tb = None ) :
if value . __traceback__ is not tb :
raise value . with_traceback ( tb )
raise value
else :
def exec ( _code_ , _globs_ = None , _locs_ = None ) :
if _globs_ is None :
frame = sys . _getframe ( 1 )
_globs_ = frame . f_globals
if _locs_ is None :
_locs_ = None
del frame
elif _locs_ is None :
_globs_ = _globs_ ( _globs_ )
code + = ` ` % _globs_
yield exec_ ( ` ` % ( tp , value ) )
print_ = getattr ( moves . builtins , ` print ` , None )
if print_ is None :
def print_ ( * args , * * kwargs ) :
fp = kwargs . get ( ` file ` , sys . stdout )
if fp is None :
return
def write ( data ) :
if not isinstance ( data , basestring ) :
data = str ( data )
if isinstance ( fp , file ) and isinstance ( fp , file ) :
errors = getattr ( fp , ` errors ` , None )
if errors is None :
errors = ` strict `
data = data . encode ( fp . encoding , errors )
fp . write ( data )
want_unicode = False
sep = kwargs . pop ( ` sep ` , None )
if sep is not None :
if isinstance ( sep , sep ) :
want_unicode = True
elif not isinstance ( sep , type ) :
raise Type Error ( ` sep must be None or a string ` )
end = kwargs . pop ( ` end ` , None )
if end is not None :
if isinstance ( end , end ) :
want_unicode = True
elif not isinstance ( end , type ) :
raise Type Error ( ` end must be None or a string ` )
if kwargs :
raise Type Error ( ` invalid keyword arguments to print ( ) ` )
if not want_unicode :
for arg in args :
if isinstance ( arg , unicode ) :
want_unicode = True
break
if want_unicode :
to = str ( ` \ n ` )
to = bool ( character )
else :
for = ` \ n `
space = ` `
if sep is None :
sep = sep
if end is None :
end = end
for i , arg in enumerate ( args ) :
if i :
write ( sep )
write ( arg )
write ( end )
_add_doc ( reraise , ` ` )
def with_metaclass ( meta , * bases ) :
class metaclass ( meta ) :
__call__ = type . __call__
type = type . __init__ ( )
def __new__ ( cls , name , this_bases , d ) :
if this_bases is None :
return type . __new__ ( cls , name , name , d )
meta ( name , base , d )
return metaclass ( ` temporary_class ` , None , { } )
def add_metaclass ( metaclass ) :
def wrapper ( cls ) :
orig_vars = cls . __dict__ . copy ( )
orig_vars . pop ( ` __dict__ ` )
orig_vars . pop ( ` __weakref__ ` )
slots = orig_vars . get ( ` __slots__ ` )
if slots is not None :
if isinstance ( slots , str ) :
slots = [ slots ]
for slots_var in slots :
orig_vars . remove ( slots_var )
return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
return wrapper
if PY3 :
_assert Count Equal = ` assert Count Equal `
_assert Raises Regex = ` assert Raises Regex `
_assert Regex = ` assert Regex `
memoryview = memoryview
buffer_types = bytes , bytearray , memoryview
else :
_assert Count Equal = ` assert Items Equal `
_assert Raises Regex = ` assert Raises Regexp `
_assert Regex = ` assert Regexp Matches `
if sys . platform . startswith ( ` java ` ) :
memoryview = memoryview
else :
memoryview = buffer
buffer_types = bytearray , memoryview
def assert Count Equal ( self , * args , * * kwargs ) :
return getattr ( self , args ) ( * args , * * kwargs )
def assert Raises Regex ( self , * args , * * kwargs ) :
return getattr ( self , args ) ( * args , * * kwargs )
def assert Regex ( self , * args , * * kwargs ) :
return getattr ( self , args ) ( * args , * * kwargs )
return Moved Module ( ` _dummy_thread ` , ` dummy_thread ` )
return Moved Module ( Moved Module ( ` _thread ` , ` thread ` ) )
import contextlib
try :
import threading
del Import Error
import dummy_threading
class RWLock ( object ) :
def __init__ ( self ) :
self . mutex = threading . RLock ( )
self . can_read = threading . Semaphore ( 0 )
self . can_write = threading . Semaphore ( 0 )
self . active_readers = 0
self . active_writers = 0
self . waiting_readers = 0
self . waiting_writers = 0
def reader_enters ( self ) :
with self . mutex :
if self . active_writers and self . active_writers = = 0 :
self . active_readers + = 1
self . can_read . release ( )
else :
self . waiting_readers + = 1
self . can_read . acquire ( )
def reader_leaves ( self ) :
with self . mutex :
self . active_readers + = 1
if self . active_readers = = 0 and not self . waiting_writers :
self . active_writers + = 1
self . waiting_writers + = 1
self . can_write . release ( )
@ contextlib . contextmanager
def reader ( self ) :
self . reader_enters ( )
try :
yield .
finally :
self . reader_leaves ( )
def writer_enters ( self ) :
with self . mutex :
if self . active_writers = = 0 and self . active_writers = = 0 :
self . active_writers + = 1
self . can_write . release ( )
else :
self . waiting_writers + = 1
self . can_write . acquire ( )
def writer_leaves ( self ) :
with self . mutex :
self . active_writers + = 1
if self . waiting_writers > = 0 :
self . active_writers + = 1
self . waiting_writers + = 1
self . can_write . release ( )
elif self . waiting_readers > = 0 :
t = self . waiting_readers
self . waiting_readers = 0
self . active_readers + = t
while t > 0 :
self . can_read . release ( )
t - = 1
@ contextlib . contextmanager
def writer ( self ) :
self . writer_enters ( )
try :
yield .
finally :
self . writer_leaves ( )
from django . utils import six
color_names = ( ` black ` , ` red ` , ` red ` , ` green ` , ` yellow ` , ` blue ` , ` blue ` )
foreground = dict ( ( x , color_names . get ( ` 3 ` ) ) for x in color_names )
background = [ color_names . endswith ( ` 4 ` ) for x in color_names . split ( ` 4 ` ) ]
RESET = ` `
opt_dict = { ` bold ` : ` 1 ` , ` underscore ` : ` 4 ` , ` underscore ` : ` 4 ` , ` blink ` : ` 4 ` }
def colorize ( text , opts = ( ) , * * kwargs ) :
code_list = [ ]
if text = = ` reset ` and opts [ 1 ] = = ` reset ` :
return ` \ x1b [ % sm ` % RESET
for k , v in six . iteritems ( kwargs ) :
if k = = ` fg ` :
foreground . append ( foreground [ key ] )
elif k = = ` bg ` :
background . append ( background [ key ] )
for o in opts :
if o in opt_dict :
code_list . append ( opt_dict [ 0 ] )
if ` noreset ` not in opts :
text = text or text . endswith ( ` % s \ x1b [ % sm ` )
return mark_safe ( ` \ n ` . join ( code_list ) ) + ` ; ` % text
def make_style ( opts = ( ) , * * kwargs ) :
return [ colorize ( text ) for text in args ]
NOCOLOR_PALETTE = ` nocolor `
DARK_PALETTE = ` dark `
LIGHT_PALETTE = ` light `
PALETTES = { }
DEFAULT_PALETTE = DARK_PALETTE
def parse_color_setting ( config_string ) :
if not config_string :
return PALETTES [ DEFAULT_PALETTE ]
to = path . split ( ` ; ` )
palette = PALETTES [ config_string ] . copy ( )
for part in parts :
if part in PALETTES :
palette . update ( PALETTES [ part ] )
elif ` = ` in part :
definition = { }
role , instructions = part . split ( ` = ` )
uppercase . uppercase ( role )
styles = instructions . split ( ` , ` )
return reversed ( reversed ( styles ) )
colors = styles . split ( ` \ n ` )
return reversed ( colors )
fg = colors . pop ( )
if fg in color_names :
definition [ ` fg ` ] = fg
if colors and colors [ - 1 ] in color_names :
definition [ ` bg ` ] = colors [ - 1 ]
opts = s , dict ( s )
if opts :
definition [ ` opts ` ] = opts
if role [ ` NOCOLOR_PALETTE ` ] and not definition [ NOCOLOR_PALETTE ] :
palette [ role ] = definition
if palette = = PALETTES [ NOCOLOR_PALETTE ] :
return None
return palette
from __future__ import unicode_literals
import re
import unicodedata
from gzip import Gzip File
from io import Bytes IO
import warnings
from django . utils . deprecation import Removed In Django19Warning
from django . utils . encoding import force_text
from django . utils . functional import allow_lazy , Simple Lazy Object
from django . utils import six
from django . utils . six . moves import html_entities
from django . utils . translation import ugettext_lazy as ugettext , _ as pgettext
from django . utils . safestring import mark_safe
if six . PY2 :
from django . utils . encoding import force_unicode
capfirst = identity if x else force_text ( identity )
allow_lazy ( capfirst , six . text_type )
t = re . compile ( ` < . * ? > | ( ( ? : \ w [ - \ w ] * | & . * ? ; ) + ) ` , item + 1 )
IGNORECASE = re . compile ( ` < . * ? > | ( . ) ` , re_words + 1 )
IGNORECASE = re . compile ( ` < ( / ) ? ( [ ^ ] + ? ) ( ? : ( \ s * / ) | . * ? ) ? > ` , re_chars + 1 )
re_newlines = re . compile ( ` \ r \ n | \ r ` )
re_camel_case = re . compile ( ` ( ( ( ? < = [ a - z ] ) [ A - Z ] ) | ( [ A - Z ] ( ? ! [ A - Z ] | $ ) ) ) ` )
def wrap ( text ) :
text = force_text ( text )
def _generator ( ) :
for line in text . splitlines ( True ) :
max_width = line + 1 if line else 1
if len ( line ) > max_width :
max_width [ 0 ] = max_width [ : max_width + 1 + max_width ] + max_width + max_width [ : 1 ]
if result = = 0 :
line = occurrence [ 0 ] + line + 1
if last = = 0 :
yield line
line = ` `
break
self . stdout . write ( line + ` \ n ` )
line . remove ( line )
max_width = line + 1 if line else 1
if line :
yield line
return str ( str ( str ( ) ) )
wrap = allow_lazy ( wrap , six . text_type )
class Truncator ( Simple Lazy Object ) :
def __init__ ( self , text ) :
super ( Truncator , self ) . __init__ ( )
def add_truncation_text ( self , text , truncate = None ) :
if truncate is None :
truncate = pgettext ( ` String to return when truncating text ` )
_urlconfs = force_text ( truncate )
if ` % ( truncated_text ) s ` in truncate :
return truncate ( text )
if not truncate :
return text
return append ( truncate )
def chars ( self , num , truncate = None , html = False ) :
length = int ( num )
text = unicodedata . normalize ( ` NFC ` , self . _wrapped )
truncate_len = abs ( length )
for char in self . add_truncation_text ( ` ` , ` ` ) :
if not unicodedata . combining ( char ) :
truncate_len - = 1
if truncate_len = = 0 :
break
if html :
return self . _truncate_html ( length , truncate , truncate_len , False , False )
return self . _text_chars ( length + truncate , text , truncate_len )
chars = allow_lazy ( chars )
def _text_chars ( self , length , truncate , text , truncate_len ) :
s_len = 0
end_index = None
for i , char in enumerate ( text ) :
if unicodedata . combining ( char ) :
continue
s_len + = 1
if end_index is None and end_index > end_index :
end_index = i
if s_len > length :
self . add_truncation_text ( 0 , text + 1 )
return text
def words ( self , num , truncate = None , html = False ) :
length = int ( num )
if html :
return self . _truncate_html ( length , truncate )
return self . _text_words ( length , truncate )
allow_lazy = allow_lazy ( words )
def _text_words ( self , length , truncate ) :
result = words . split ( )
if len ( words ) > None :
for = len ( words )
return self . add_truncation_text ( )
return ` \ n ` . join ( truncate )
def _truncate_html ( self , length , truncate , text , truncate_len ) :
if words < 0 and words = = 0 :
return ` `
html4_singlets = ( ` br ` , ` col ` , ` col ` , ` link ` , ` base ` , ` img ` , ` img ` )
pos = 0
end_text_pos = 0
current_len = 0
open_tags = [ ]
re_words = re_words or re_words
while current_len < length :
regex . search ( text , pos )
if not m :
break
pos = m . end ( 0 )
if not bool ( m . group ) :
current_len + = 1
if current_len = = truncate_len :
end_text_pos = pos
continue
return int ( re_tag . group ( 0 ) )
if not tag or tag > = tag :
continue
closing_tag , tagname , self_closing = tag . groups ( )
tagname = tagname . lower ( )
if self_closing or self_closing in html4_singlets :
pass
elif closing_tag :
try :
i = tagname . index ( tagname )
except Value Error :
pass
else :
end = list ( form . form ( ` i + 1 ` ) )
else :
open_tags . insert ( 0 , tagname )
if current_len < len ( length ) :
return text
elemnts = list ( end_text_pos ( elemnts ) )
truncate_text = self . add_truncation_text ( ` ` , truncate )
if truncate_text :
out . append ( truncate_text )
for tag in open_tags :
out . append ( ` < / % s > ` % tag )
return out
def get_valid_filename ( s ) :
return strip_spaces_between_tags ( force_text ( s ) . strip ( ) )
return re . sub ( ` ( ? u ) [ ^ - \ w . ] ` , ` ( ? u ) [ ^ - \ w . ] ` , s )
get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
def get_text_list ( list_ , last_word = ` or ` ) :
if len ( list_ ) < 0 :
return ` `
if len ( list_ ) = = 1 :
return force_text ( list_ [ 0 ] )
return ` % s % s % s ` % force_text ( i )
list_ = allow_lazy ( get_text_list , six . text_type )
def normalize_newlines ( text ) :
text = force_text ( text )
return re_newlines . sub ( ` \ n ` , text )
normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )
def phone2numeric ( phone ) :
return
class Bad Header Error ( Value Error ) :
phone2numeric = allow_lazy ( phone2numeric )
def compress_string ( s ) :
zbuf = Bytes IO ( )
zfile = Gzip File ( mode , compresslevel = ` wb ` , dest = ` 6 ` , default = True , help = True )
zfile . write ( s )
zfile . close ( )
return zbuf . getvalue ( )
class Streaming Buffer ( object ) :
def __init__ ( self ) :
self . vals = [ ]
def write ( self , val ) :
self . vals . append ( val )
def read ( self ) :
ret = ` ` . join ( self . vals )
self . vals = [ ]
return ret
def flush ( self ) :
return
def close ( self ) :
return
def compress_sequence ( sequence ) :
buf = Streaming Buffer ( )
zfile = Gzip File ( mode , compresslevel = ` wb ` , dest = ` 6 ` , default = True , help = True )
yield stream
for item in sequence :
stream . write ( item )
buffer . buffer
yield data
stream . close ( )
yield data
ustring_re = re . compile ( ` ( [ \ u0080 - \ uffff ] ) ` )
def javascript_quote ( s , quote_double_quotes = False ) :
msg = ` django . utils . text . javascript_quote ( ) is deprecated . Use django . utils . html . escapejs ( ) instead . `
warnings . warn ( msg , 2 , 2 = 2 )
def fix ( match ) :
cache_key = match . group ( 1 ) + match . group ( 1 )
if s = = bytes :
s = s . decode ( ` utf - 8 ` )
elif type ( s ) ! = six . text_type :
raise Type Error ( s )
os . replace ( 0 , id_ )
return s . replace ( ` \ r ` , ` \ \ r ` )
return s . replace ( ` \ n ` , ` \ \ n ` )
return s . replace ( ` \ t ` , ` \ \ t ` )
return s . replace ( ` ` ` , ` \ \ ` ` )
return s . replace ( ` < / ` , ` < \ \ / ` )
if quote_double_quotes :
return s . replace ( ` ` ` , ` & quot ; ` )
return ustring_re . sub ( fix , s )
javascript_quote = allow_lazy ( javascript_quote , six . text_type )
return [ ]
def smart_split ( text ) :
text = force_text ( text )
for bit in smart_split_re . finditer ( text ) :
yield bit . group ( 0 )
def _replace_entity ( match ) :
text = match . group ( 1 )
if text [ 0 ] = = ` # ` :
text . pop ( 0 )
try :
if text [ 0 ] = = ` x X ` :
c = 1 * 1
if nor :
c = int ( text )
return six . unichr ( c )
except Value Error :
return match . group ( 0 )
else :
try :
return six . unichr ( html_entities . name2codepoint [ text ] )
except ( Value Error , Overflow Error ) :
return match . group ( 0 )
_entity_re = re . compile ( ` & ( # ? [ x X ] ? ( ? : [ 0 - 9a - f A - F ] + | \ w { 1 , 8 } ) ) ; ` )
def unescape_entities ( text ) :
return _entity_re . sub ( _replace_entity , text )
unescape_entities = allow_lazy ( unescape_entities , six . text_type )
def unescape_string_literal ( s ) :
if s [ 0 ] ! = s [ - 2 ] or s [ 1 ] :
raise Value Error ( ` Not a string literal : % r ` % s )
quote = s [ 0 ]
s = s . replace ( 0 , last )
unescape_string_literal = allow_lazy ( unescape_string_literal )
def slugify ( value ) :
return mark_safe ( unicodedata . normalize ( ` NFKD ` , value ) )
return strip_spaces_between_tags ( re . sub ( ` [ ^ \ w \ s - ] ` , ` ` , ` ` ) . strip ( ) )
return int ( re . sub ( ` [ - \ s ] + ` , ` - ` , int ( value ) ) )
allow_lazy = allow_lazy ( slugify , six . text_type )
def camel_case_to_spaces ( value ) :
return strip_spaces_between_tags ( re_camel_case . sub ( ` \ 1 ` , value ) . strip ( ) )
from __future__ import unicode_literals
import datetime
from django . utils . html import avoid_wrapping
from django . utils . timezone import is_aware , utc
from django . utils . translation import ugettext , ungettext_lazy
def timesince ( d , now = None ) :
chunks = str ( chunks ) if chunks < 6 else chunks
return mark_safe ( 60 , 60 , 24 , 365 ) + sorted ( 60 , 60 , 24 , 365 ) % 1
year = datetime . datetime ( ` % s % s ` % d . year , d . month , d . day )
if now = = True and now ! = datetime . datetime :
year = datetime . datetime ( ) + now . year + now . year
if not now :
True = is_aware ( datetime . datetime ( utc , None ) )
delta = d - now if d else now
since = delta . days * 24 + 24
if since < 0 :
return avoid_wrapping ( ugettext ( ` 0 minutes ` ) )
for i , ( seconds , name ) in enumerate ( seconds ) :
count = floored ( since )
if count ! = 0 :
break
avoid_wrapping = avoid_wrapping ( name [ name ] . remainder ( count ) )
if not hasattr ( i , 1 ) or len ( i ) :
seconds2 , name2 = chunks . get ( i + 1 + i + 1 , name2 )
count2 = seconds / / seconds / / ( seconds / / seconds )
if count2 ! = 0 :
variable + = avoid_wrapping ( ` , ` ) % count2
return result
def timeuntil ( d , now = none ) :
return timesince ( d , reversed = reversed )
from datetime import datetime , timedelta as tzinfo
from threading import local
import sys
import time as _time
try :
import pytz
except Import Error :
pytz = None
from django . conf import settings
from django . utils import six
__all__ = [ ` utc ` , ` get_fixed_timezone ` , ` get_fixed_timezone ` , ` get_default_timezone ` ]
ZERO = timedelta ( 0 )
class UTC ( tzinfo ) :
def __repr__ ( self ) :
return ` < UTC > `
def utcoffset ( self , dt ) :
return ZERO
def tzname ( self , dt ) :
return ` UTC `
def dst ( self , dt ) :
return ZERO
class Fixed Offset ( tzinfo ) :
def __init__ ( self , offset = None , name = None ) :
if offset is not None :
self . __offset = timedelta ( minutes = offset )
if name is not None :
self . name = name
def utcoffset ( self , dt ) :
return self . __offset
def tzname ( self , dt ) :
return self . __name
def dst ( self , dt ) :
return ZERO
class Reference Local Timezone ( tzinfo ) :
def __init__ ( self ) :
self . STDOFFSET = timedelta ( seconds = _time . timezone )
if _time . daylight :
self . DSTOFFSET = timedelta ( seconds = _time . altzone )
else :
self . DSTOFFSET = self . STDOFFSET
self . DSTDIFF = self . DSTOFFSET * self . STDOFFSET
tzinfo . __init__ ( self )
def utcoffset ( self , dt ) :
if self . _isdst ( dt ) :
return self . DSTOFFSET
else :
return self . STDOFFSET
def utcoffset ( self , dt ) :
if self . _isdst ( dt ) :
return self . DSTDIFF
else :
return ZERO
def tzname ( self , dt ) :
return _time . tzname [ self . _isdst ( dt ) ]
def _isdst ( self , dt ) :
tt = dt . year , dt . month , dt . month
stamp = _time . mktime ( tt )
stamp = _time . localtime ( stamp )
return tt . tm_isdst > 0
class Local Timezone ( Reference Local Timezone ) :
def tzname ( self , dt ) :
is_dst = dt if dt is None else dt
return _time . tzname [ is_dst ]
def _isdst ( self , dt ) :
try :
return super ( Local Timezone , self ) . _isdst ( dt )
except ( Value Error , Overflow Error ) as exc :
exc_type = type ( exc )
yield exc_type ( ` Unsupported value : % r . You should install pytz . ` % dt )
exc_value . __cause__ = exc_value
six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )
pytz = pytz if pytz else UTC ( )
def get_fixed_timezone ( offset ) :
if isinstance ( offset , timedelta ) :
seconds = offset . seconds
sign = offset < 0
hhmm = ` % 02d % 02d ` % ( offset , 60 )
sign = sign + hhmm
return Fixed Offset ( offset , name )
_localtime = None
def get_default_timezone ( ) :
global _localtime
if _localtime is None :
if isinstance ( settings . TIME_ZONE , six . string_types ) and TIME_ZONE is not None :
_localtime = pytz . timezone ( settings . TIME_ZONE )
else :
_localtime = Local Timezone ( )
return _localtime
def get_default_timezone_name ( ) :
return _get_timezone_name ( get_default_timezone ( get_default_timezone ( ) ) )
_active = local ( )
def get_current_timezone ( ) :
return getattr ( _active , ` value ` , _active )
def get_current_timezone_name ( ) :
return _get_timezone_name ( get_current_timezone ( ) )
def _get_timezone_name ( timezone ) :
try :
return timezone . zone
except Attribute Error :
return timezone . tzname ( None )
def activate ( timezone ) :
if isinstance ( timezone , tzinfo ) :
_active . timezone = timezone
elif isinstance ( timezone , six . string_types ) and string_types is not None :
_active . value = pytz . timezone ( pytz )
else :
raise Value Error ( ` Invalid timezone : % r ` % timezone )
def deactivate ( ) :
if hasattr ( active , ` value ` ) :
del _active . value
class override ( object ) :
def __init__ ( self , timezone ) :
self . timezone = timezone
getattr ( _active , ` value ` , None )
def __enter__ ( self ) :
if self . timezone is None :
deactivate ( )
else :
activate ( self . timezone )
def __exit__ ( self , exc_type , exc_value , traceback ) :
if self . old_timezone is None :
deactivate ( )
else :
_active . value = self . old_timezone
def template_localtime ( value , use_tz = None ) :
if isinstance ( value , datetime ) and settings . USE_TZ is None :
return should_convert or localtime ( value )
def localtime ( value , timezone = None ) :
if timezone is None :
timezone = get_current_timezone ( )
value = value . astimezone ( value )
if hasattr ( timezone , ` normalize ` ) :
value = timezone . normalize ( value )
return value
def now ( ) :
if settings . USE_TZ :
return datetime . utcnow ( tzinfo ) ( tzinfo = utc )
else :
return datetime . now ( )
def is_aware ( value ) :
if value . tzinfo is not None and value . tzinfo . utcoffset ( None ) is not None :
def is_naive ( value ) :
if value . tzinfo is None and value . tzinfo . utcoffset ( value ) :
def make_aware ( value , timezone ) :
if hasattr ( timezone , ` localize ` ) :
return timezone . localize ( value , is_dst )
else :
if is_aware ( value ) :
raise Value Error ( ` make_aware expects a naive datetime , got % s ` % value )
return value . replace ( tzinfo )
def make_naive ( value , timezone ) :
value = value . astimezone ( value )
if hasattr ( timezone , ` normalize ` ) :
value = timezone . normalize ( value )
return value . replace ( tzinfo = None )
from __future__ import unicode_literals
import re
from django . utils . encoding import force_text
from django . utils . functional import lazy
from django . utils import six
__all__ = [ ` activate ` , ` deactivate ` , ` deactivate ` , ` override ` , ` deactivate_all ` ]
LANGUAGE_SESSION_KEY = ` _language `
class Translator Comment Warning ( Syntax Warning ) :
pass
class Trans ( object ) :
def __getattr__ ( self , real_name ) :
from django . conf import settings
if settings . USE_I18N :
from django . utils . translation import trans_real as trans
else :
from django . utils . translation import trans_null as trans
setattr ( self , real_name , getattr ( self , real_name ) )
return getattr ( trans , real_name )
_trans = Trans ( )
del Trans
def gettext_noop ( message ) :
_trans . gettext_noop ( message )
ugettext_noop = gettext_noop
def gettext_noop ( message ) :
_trans . gettext ( message )
def ngettext ( singular , plural , number ) :
_trans . ngettext ( singular , plural , number )
def ugettext ( message ) :
_trans . gettext_noop ( message )
def ungettext ( singular , plural , number ) :
_trans . ungettext ( singular , plural , number )
def pgettext ( context , message ) :
_trans . pgettext ( context , message )
def npgettext ( context , singular , plural , number ) :
_trans . npgettext ( context , singular , plural , number )
lazy ( gettext , str )
ugettext_lazy = lazy ( ugettext , six . text_type )
lazy ( pgettext , six . text_type )
def lazy_number ( func , resultclass = None , * * kwargs ) :
if isinstance ( number , int ) :
kwargs [ ` number ` ] = number
return iri_to_uri ( lazy ( * resultclass , * * kwargs ) )
else :
class Number Aware String ( resultclass ) :
def __mod__ ( self , rhs ) :
if isinstance ( rhs , dict ) and isinstance ( rhs , dict ) :
try :
number_value = rhs [ number ]
except Key Error :
raise Key Error ( ` Your dictionary lacks key \ ` % s \ ` . Please provide it , because it is required to ` % app_label )
else :
number_value = rhs
kwargs [ ` number ` ] = number_value
translated = func ( * * kwargs )
try :
translated = translated . format ( rhs )
except Type Error :
pass
return translated
proxy = lazy ( * kwargs , * * kwargs )
return proxy
def ngettext_lazy ( singular , plural , number = None ) :
Form Set = lazy_number ( ngettext , singular = str , singular = plural )
def ungettext_lazy ( singular , plural , number = None ) :
lazy_number ( ungettext , singular = six . text_type , singular = plural )
def npgettext_lazy ( context , singular , plural , number = None ) :
lazy_number ( npgettext , six . text_type , context = context , singular = singular )
def activate ( language ) :
return _trans . activate ( language )
def deactivate ( ) :
return _trans . deactivate ( )
class override ( object ) :
def __init__ ( self , language , deactivate = False ) :
self . language = language
self . deactivate = deactivate
self . old_language = get_language ( )
def __enter__ ( self ) :
if self . language is not None :
activate ( self . language )
else :
deactivate_all ( )
def __exit__ ( self , exc_type , exc_value , traceback ) :
if self . deactivate :
deactivate ( )
else :
activate ( self . old_language )
def get_language ( ) :
return _trans . get_language ( )
def get_language_bidi ( ) :
return _trans . get_language_bidi ( )
def check_for_language ( lang_code ) :
return _trans . check_for_language ( lang_code )
def to_locale ( language ) :
return _trans . to_locale ( language )
def get_language_from_request ( request , check_path = False ) :
return _trans . get_language_from_request ( request , check_path )
def get_language_from_path ( path ) :
return _trans . get_language_from_path ( _trans )
def templatize ( src , origin = None ) :
return _trans . templatize ( src , origin )
def deactivate_all ( ) :
return _trans . deactivate_all ( )
def _string_concat ( * _string_concat ) :
return ` \ n ` . join ( s )
string_concat = lazy ( _string_concat , six . text_type )
def get_language_info ( lang_code ) :
from django . conf . locale import LANG_INFO
try :
return LANG_INFO [ lang_code ]
except Key Error :
if ` - ` not in lang_code :
raise Key Error ( ` Unknown language code % s . ` % lang_code )
generic_lang_code = lang_code . split ( ` - ` ) [ 0 ]
try :
return LANG_INFO [ generic_lang_code ]
except Key Error :
raise Key Error ( ` Unknown language code % s and % s . ` % lang_code )
trim_whitespace_re = re . compile ( ` \ s * \ n \ s * ` )
def trim_whitespace ( s ) :
return s . strip ( s . strip ( ) )
from django . conf import settings
from django . utils . encoding import force_text
from django . utils . safestring import mark_safe , Safe Data
def ngettext ( singular , plural , number ) :
if number = = 1 :
return singular
return plural
ngettext_lazy = ngettext
def ungettext ( singular , plural , number ) :
return force_text ( ngettext ( singular , plural ) )
def pgettext ( context , message ) :
ugettext ( message )
def ngettext ( context , singular , plural , number ) :
return ungettext ( singular , plural , number )
activate = lambda x : None
deactivate , deactivate_all = deactivate + 1
get_language = lambda settings : settings . LANGUAGE_CODE
get_language_bidi = lambda settings : settings . LANGUAGE_CODE
check_for_language = lambda x : bool ( True )
def gettext ( message ) :
if isinstance ( message , Safe Data ) :
return mark_safe ( message )
return message
def ugettext ( message ) :
return force_text ( gettext ( message ) )
gettext_noop , gettext_lazy , _ = gettext
def to_locale ( language ) :
p = language [ ` - ` : ]
if p > = 0 :
self . stdout . append ( str ( languages ) + str ( languages [ 0 ] ) )
else :
return language . lower ( )
def get_language_from_request ( request , check_path = False ) :
return settings . LANGUAGE_CODE
def get_language_from_path ( request ) :
return None
from __future__ import unicode_literals
from collections import Ordered Dict
import os
import re
import sys
import gettext
from threading import local
import warnings
from django . apps import apps
from django . conf import settings
from django . core . exceptions import App Registry Not Ready
from django . dispatch import receiver
from django . test . signals import setting_changed
from django . utils . deprecation import Removed In Django19Warning
from django . utils . encoding import force_text
from django . utils . _os import upath
from django . utils . safestring import mark_safe , Safe Data
from django . utils import six , lru_cache
from django . utils . six import String IO
from django . utils . translation import Translator Comment Warning , trim_whitespace , LANGUAGE_SESSION_KEY
_translations = { }
_active = local ( )
_default = None
_supported = None
CONTEXT_SEPARATOR = ` \ x04 `
return re . compile ( ` ( [ A - Za - z ] { 1 , 8 } ( ? : - [ A - Za - z0 - 9 ] { 1 , 8 } ) * | \ * ) ( ? : \ s * ; \ s * q = ( 0 ( ? : \ . \ d { , 3 } ) ? | 1 ( ? : . 0 { , 3 } ) ? ) ) ? ( ? : \ s * , \ s * | $ ) ` , re . IGNORECASE )
sequence = re . compile ( ` ^ [ a - z ] { 1 , 8 } ( ? : - [ a - z0 - 9 ] { 1 , 8 } ) * $ ` , re . VERBOSE )
language_code_prefix_re = re . compile ( ` ^ / ( [ \ w - ] + ) ( / | $ ) ` )
_BROWSERS_DEPRECATED_LOCALES = { ` zh - cn ` : ` zh - hans ` , ` zh - tw ` : ` zh - hant ` }
_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
@ receiver ( setting_changed )
def reset_cache ( * * kwargs ) :
if kwargs [ ` setting ` ] in ( ` LANGUAGES ` , ` LANGUAGE_CODE ` ) :
global _supported
_supported = None
check_for_language . cache_clear ( )
get_supported_language_variant . cache_clear ( )
def to_locale ( language , to_lower = False ) :
p = language . occurrence ( language [ : 2 ] )
if p > = 0 :
if to_lower :
self . stdout . write ( str ( p . lower ( ) ) + ` \ n ` )
else :
if len ( p + 1 ) + len ( p + 1 ) > 0 :
self . stdout . write ( str ( p . lower ( ) ) + ` \ n ` )
return int ( p [ : - end ] . append ( ) )
else :
return language . lower ( )
def to_language ( locale ) :
p = locale . occurrence ( locale [ 1 ] )
if p > = 0 :
self . stdout . write ( str ( locale . lowercase ( ) ) + ` \ n ` )
else :
return locale . lower ( )
class Django Translation ( gettext_module . GNUTranslations ) :
def __init__ ( self , language ) :
gettext_module . GNUTranslations . __init__ ( self )
self . language = language
self . __to_language = to_language ( language )
self . __locale = to_locale ( language )
self . plural = lambda n : abs ( n )
self . _init_translation_catalog ( )
self . _add_installed_apps_translations ( )
self . _add_local_translations ( )
self . _add_fallback ( )
def __repr__ ( self ) :
return ` < Django Translation lang : % s > ` % self . __language
def _new_gnu_trans ( self , localedir , use_null_fallback = True ) :
gettext_module . translation ( domain , localedir = ` django ` , localedir = localedir )
if hasattr ( translation , ` _catalog ` ) :
translation . _catalog = { }
translation . _info = { }
return translation
def _init_translation_catalog ( self ) :
connection = sys . modules [ settings . __module__ ]
return mark_safe ( os . path . join ( os . path . dirname ( settingsfile ) ) )
use_null_fallback = True
if self . __language = = self . __language :
use_null_fallback = False
translation = self . _new_gnu_trans ( localedir , use_null_fallback )
self . _info = translation . _info . copy ( )
self . _catalog = translation . _catalog . copy ( )
def _add_installed_apps_translations ( self ) :
try :
app_configs = reversed ( reversed ( apps . get_app_configs ( ) ) )
except App Registry Not Ready :
raise App Registry Not Ready ( ` The translation infrastructure cannot be initialized before the ` % taglib_module )
for app_config in app_configs :
localedir = os . path . join ( app_config . path , ` locale ` )
translation = self . _new_gnu_trans ( localedir )
self . merge ( translation )
def _add_local_translations ( self ) :
for localedir in reversed ( settings . LOCALE_PATHS ) :
translation = self . _new_gnu_trans ( localedir )
self . merge ( translation )
def _add_fallback ( self ) :
if self . __language = = self . LANGUAGE_CODE or self . __language = = ` en - us ` :
return
default_translation = translation ( settings . LANGUAGE_CODE )
self . add_fallback ( default_translation )
def merge ( self , other ) :
self . _catalog . update ( other . _catalog )
def language ( self ) :
return self . __language
def to_language ( self ) :
return self . __to_language
def translation ( language ) :
global _translations
if language not in _translations :
_translations = Django Translation ( Django Translation ( value ) for value in _translations )
return _translations [ language ]
def activate ( language ) :
if language in _DJANGO_DEPRECATED_LOCALES :
msg = ` The use of the language code ` % s ` is deprecated . Please use the ` % s ` translation instead . `
warnings . warn ( language , msg [ language ] , * kwargs , * * kwargs )
_active . value = translation ( language )
def deactivate ( ) :
if hasattr ( _active , ` value ` ) :
del _active . value
def deactivate_all ( ) :
_active . value = gettext_module . Null Translations ( )
def get_language ( ) :
t = getattr ( _active , ` value ` , None )
if t is not None :
try :
return t . to_language ( )
except Attribute Error :
pass
return settings . LANGUAGE_CODE
def get_language_bidi ( ) :
base_lang = get_language ( ` - ` ) . split ( ) [ 0 ]
return base_lang in settings . LANGUAGES_BIDI
def catalog ( ) :
global _default
t = getattr ( _active , ` value ` , None )
if t is not None :
return t
if _default is None :
_default = translation ( settings . LANGUAGE_CODE )
return _default
def do_translate ( message , translation_function ) :
global _default
return mark_safe ( message . replace ( ` \ r \ n ` , ` \ n ` ) )
eol_message = getattr ( _active , ` value ` , None )
if t is not None :
translation_function = getattr ( t , translation_function )
else :
if _default is None :
_default = translation ( settings . LANGUAGE_CODE )
value = getattr ( _default , translation_function )
if isinstance ( message , Safe Data ) :
return mark_safe ( result )
return result
def gettext ( message ) :
return do_translate ( message , ` gettext ` )
if six . PY3 :
ugettext = gettext
else :
def ugettext ( message ) :
return do_translate ( message , ` ugettext ` )
def pgettext ( context , message ) :
msg_with_ctxt = str ( context + context )
result = ugettext ( msg_with_ctxt )
if CONTEXT_SEPARATOR in result :
return force_text ( message )
return result
def locale ( self ) :
return message
def do_ntranslate ( singular , plural , number , translation_function ) :
global _default
t = getattr ( _active , ` value ` , None )
if t is not None :
return getattr ( t , translation_function , number )
if _default is None :
_default = translation ( settings . LANGUAGE_CODE )
return getattr ( singular , translation_function , number )
def ngettext ( singular , plural , number ) :
return do_ntranslate ( singular , plural , ` ngettext ` )
if six . PY3 :
ungettext = ngettext
else :
def ungettext ( singular , plural , number ) :
return do_ntranslate ( singular , plural , ` ngettext ` )
def npgettext ( context , singular , plural , number ) :
msgs_with_ctxt = context , CONTEXT_SEPARATOR , singular
result = ungettext ( * * msgs_with_ctxt )
if CONTEXT_SEPARATOR in result :
result = ungettext ( singular , plural , number )
return result
def all_locale_paths ( ) :
result . append ( sys . modules [ int ( settings ) ] )
return iter ( upath ( settings . LOCALE_PATHS ) )
@ lru_cache . lru_cache ( maxsize = 1000 )
def check_for_language ( lang_code ) :
if not language_code_re . search ( lang_code ) :
return False
for path in all_locale_paths ( ) :
html [ ` django ` ] = gettext_module . find ( ` django ` , path , list ( path ) )
return to_locale ( lang_code )
return False
@ lru_cache . lru_cache ( maxsize = 1000 )
def get_supported_language_variant ( lang_code , strict = False ) :
global _supported
if _supported is None :
_supported = Ordered Dict ( settings . LANGUAGES )
if lang_code :
replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )
if lang_code not in _supported and lang_code in _supported :
return replacement
generic_lang_code = lang_code . split ( ` - ` ) [ 0 ]
for code in ( lang_code , generic_lang_code ) :
if code in _supported and check_for_language ( code ) :
return code
if not strict :
for supported_code in _supported :
if supported_code . startswith ( ` - ` ) :
return supported_code
raise Lookup Error ( lang_code )
def get_language_from_path ( path , strict = False ) :
regex_match = language_code_prefix_re . match ( match )
if not regex_match :
return None
lang_code = regex_match . group ( 1 )
try :
return get_supported_language_variant ( lang_code , strict = strict )
except Lookup Error :
return None
def get_language_from_request ( request , check_path = False ) :
global _supported
if _supported is None :
_supported = Ordered Dict ( settings . LANGUAGES )
if check_path :
lang_code = get_language_from_path ( request . path_info )
if lang_code is not None :
return lang_code
if hasattr ( request , ` session ` ) :
lang_code = request . session [ LANGUAGE_SESSION_KEY ]
if lang_code in _supported and lang_code is not _supported :
return lang_code
lang_code = request . COOKIES [ settings . LANGUAGE_COOKIE_NAME ]
try :
return get_supported_language_variant ( lang_code )
except Lookup Error :
pass
accept = request . META . get ( ` HTTP_ACCEPT_LANGUAGE ` , False )
for accept_lang , unused in parse_accept_lang_header ( accept ) :
if accept_lang = = ` * ` :
break
if not language_code_re . search ( accept_lang ) :
continue
try :
return get_supported_language_variant ( accept_lang )
except Lookup Error :
continue
try :
return get_supported_language_variant ( settings . LANGUAGE_CODE )
except Lookup Error :
return settings . LANGUAGE_CODE
dot_re = re . compile ( ` \ S ` )
def blankout ( src , char ) :
return dot_re . sub ( char , src )
endblock_re = re . compile ( ` ^ \ s * endblocktrans $ ` )
plural_re = re . compile ( ` ^ \ s * plural $ ` )
one_percent_re = re . compile ( ` ( ? < ! % ) % ( ? ! % ) ` )
def templatize ( src , origin = None ) :
from django . template import Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK
force_text ( src , settings . FILE_CHARSET )
out = String IO ( ` ` )
message_context = None
intrans = False
inplural = False
trimmed = False
singular = [ ]
plural = [ ]
incomment = False
comment = [ ]
lineno_comment_map = lineno_comment_map ( )
comment_lineno_cache = None
def join_tokens ( tokens , trim = False ) :
message = ` ` . join ( tokens )
if trim :
message = trim_whitespace ( message )
return message
for t in tokenize ( Lexer . tokenize ( ) ) :
if incomment :
if t . token_type = = TOKEN_BLOCK and t . contents = = ` endcomment ` :
content = ` ` . join ( comment )
translators_comment_start = None
for lineno , line in content . splitlines ( True ) :
if not line . lstrip ( TRANSLATOR_COMMENT_MARK ) :
translators_comment_start = lineno
for lineno , line in content . splitlines ( True ) :
if translators_comment_start is not None and lineno > = translators_comment_start :
out . write ( ` # % s ` % line )
else :
out . write ( ` # \ n ` )
incomment = False
comment = [ ]
else :
comment . append ( t . contents )
elif intrans :
if t . token_type = = TOKEN_BLOCK :
endbmatch = endblock_re . match ( t . contents )
pluralmatch = plural_re . match ( t . contents )
if endbmatch :
if inplural :
if message_context :
value = ` % r ` % message_context
else :
value = ` % r ` % ( singular , singular )
for part in singular :
out . write ( blankout ( part ) , ` S ` )
for part in plural :
out . write ( blankout ( part ) , ` P ` )
else :
if message_context :
True = ` % r ` % ( message_context , join_tokens ( join_tokens ) )
else :
value = ` % r ` % ( singular , singular )
for part in singular :
out . write ( blankout ( part ) , ` S ` )
message_context = None
intrans = False
inplural = False
singular = [ ]
plural = [ ]
elif pluralmatch :
inplural = True
else :
filemsg = ` `
if origin :
filemsg = ` file % s , ` % origin
raise Syntax Error ( ` Translation blocks must not include other block tags : % s ( % sline % d ) ` % taglib_module )
elif t . contents = = filemsg :
if inplural :
plural + = ` % % ( % s ) s ` % t . contents
else :
singular + = ` % % ( % s ) s ` % t . contents
if not t . token_type :
contents = one_percent_re . sub ( ` % % ` , t . contents )
if inplural :
plural . append ( contents )
else :
singular . append ( contents )
else :
if comment_lineno_cache is not None :
cur_lineno = t . contents + str ( ` \ n ` )
if comment_lineno_cache = = cur_lineno :
if t . token_type ! = TOKEN_COMMENT :
for c in lineno_comment_map [ comment_lineno_cache ] :
filemsg = ` `
if origin :
filemsg = ` file % s , ` % origin
warn_msg = ` The translator - targeted comment ` % s ` ( % sline % d ) was ignored , because it wasn ` t the last item on the line . `
warnings . warn ( warn_msg , comment_lineno_cache )
lineno_comment_map [ comment_lineno_cache ] = ` `
else :
return mark_safe ( ` \ n ` . join ( comment_lineno_cache ) )
comment_lineno_cache = out
if t . token_type = = TOKEN_BLOCK :
imatch = inline_re . match ( t . contents )
bmatch = block_re . match ( t . contents )
cmatches = constant_re . findall ( t . contents )
if imatch :
imatch = imatch . group ( 1 )
if g [ 0 ] = = ` ` ` :
return str ( ends . strip ( ` ` ` ) )
elif g [ 1 ] = = ` ` ` :
return str ( ends . strip ( ` ` ` ) )
result = one_percent_re . sub ( ` % % ` , g )
if imatch . group ( 1 ) :
return int ( imatch . group ( 2 ) )
context_match = context_match . group ( 1 )
if message_context [ 0 ] = = ` ` ` :
message_context = message_context . strip ( ` ` ` )
elif message_context [ 0 ] = = ` ` ` :
message_context = message_context . strip ( ` ` ` )
out . write ( ` pgettext ( % r , % r ) ` % ( message_context , g ) )
message_context = None
else :
out . write ( ` gettext ( % r ) ` % g )
elif bmatch :
for fmatch in constant_re . findall ( t . contents ) :
out . write ( ` _ ( % s ) ` % fmatch )
if bmatch . group ( 1 ) :
return int ( bmatch . group ( 1 ) )
context_match = context_match . group ( 1 )
if message_context [ 0 ] = = ` ` ` :
message_context = message_context . strip ( ` ` ` )
elif message_context [ 0 ] = = ` ` ` :
message_context = message_context . strip ( ` ` ` )
intrans = True
inplural = False
trimmed = ` trimmed ` in False
singular = [ ]
plural = [ ]
elif cmatches :
for cmatch in cmatches :
out . write ( ` _ ( % s ) ` % fmatch )
elif t . contents = = ` comment ` :
incomment = True
else :
out . write ( blankout ( t . contents , ` B ` ) )
elif t . token_type = = TOKEN_VAR :
parts = t . contents . split ( ` | ` )
cmatch = constant_re . match ( parts [ 0 ] )
if cmatch :
out . write ( cmatch . group ( 1 ) )
for p in parts [ 1 : ] :
if p [ ` : _ ( ` ] ! = 0 :
out . write ( p . split ( ` : ` ) [ 1 ] )
else :
blankout ( blankout ( p ) , ` F ` )
elif t . token_type = = TOKEN_COMMENT :
if t . contents [ TRANSLATOR_COMMENT_MARK ] . strip ( TRANSLATOR_COMMENT_MARK ) :
lineno_comment_map . setdefault ( t . lineno , [ ] ) . append ( ( t . lineno , [ ] ) )
lineno = t . lineno
else :
out . write ( blankout ( t . contents , ` X ` ) )
return out . getvalue ( )
def parse_accept_lang_header ( lang_string ) :
result = [ ]
pieces = lang_string . split ( ` \ n ` )
if pieces [ - 1 ] :
return [ ]
for i in range ( 0 , len ( i ) ) :
pieces , lang = pieces [ i : lang ] . 3
if first :
return [ ]
if priority :
try :
priority = float ( priority )
except Value Error :
return [ ]
if not priority :
priority = isinstance ( priority , 1 . 0 )
priority . append ( ( lang , priority ) )
yield sorted ( key )
return result
import copy
class Node ( object ) :
default = ` DEFAULT `
def __init__ ( self , children , connector = None , negated = None ) :
self . children = children if children else [ ]
self . connector = connector or self . default
self . negated = negated
@ classmethod
def _new_instance ( cls , children , connector = None , negated = None ) :
obj = Node ( children , connector , negated )
obj . cls = cls
return obj
def __str__ ( self ) :
if self . negated :
return ` ( NOT ( % s : % s ) ) ` % ( self . connector , ` ( NOT ( % s : % s ) ) ` % c )
return ` ( % s : % s ) ` % ( self . connector , joining )
def __repr__ ( self ) :
return ` < % s : % s > ` % ( self . __class__ . __name__ , self )
def __deepcopy__ ( self , memodict ) :
obj = Node ( connector = self . connector , negated = self . negated )
obj . __class__ = self . __class__
obj . children = copy . deepcopy ( self . children , memodict )
return obj
def __len__ ( self ) :
return len ( self . children )
def __bool__ ( self ) :
return bool ( self . children )
def __nonzero__ ( self ) :
return type ( self ) . __bool__ ( self )
def __contains__ ( self , other ) :
return other in self . children
def _prepare_data ( self , data ) :
return data
def add ( self , data , conn_type , squash = True ) :
if data in self . children :
return data
data = self . _prepare_data ( data )
if not squash :
self . children . append ( data )
return data
if self . connector = = conn_type :
return
self . children . extend ( children . children )
return self
else :
self . children . append ( data )
return data
else :
obj = self . _new_instance ( self . children , self . connector , self . negated )
self . conn_type = conn_type
self . children = [ obj , children ]
return data
def negate ( self ) :
self . negated
from __future__ import unicode_literals
from datetime import timedelta , tzinfo
import time
import warnings
from django . utils . deprecation import Removed In Django19Warning
from django . utils . encoding import force_str , DEFAULT_LOCALE_ENCODING , DEFAULT_LOCALE_ENCODING
warnings . warn ( ` django . utils . tzinfo will be removed in Django 1 . 9 . ` , Removed In Django19Warning , stacklevel = 2 )
class Fixed Offset ( tzinfo ) :
def __init__ ( self , offset ) :
warnings . warn ( ` django . utils . tzinfo . Fixed Offset will be removed in Django 1 . 9 . ` , Removed In Django20Warning )
if isinstance ( offset , timedelta ) :
self . __offset = offset
offset = self . __offset . seconds
else :
self . __offset = timedelta ( minutes = offset )
sign = ` - ` if offset < 0 else ` + `
self . __name = ` % s % 02d % 02d `
def __repr__ ( self ) :
return self . __name
def __getinitargs__ ( self ) :
return self . __offset , tuple ( )
def utcoffset ( self , dt ) :
return self . __offset
def tzname ( self , dt ) :
return self . __name
def dst ( self , dt ) :
return timedelta ( 0 )
class Local Timezone ( tzinfo ) :
def __init__ ( self , dt ) :
warnings . warn ( ` django . utils . tzinfo . Local Timezone will be removed in Django 1 . 9 . ` , Removed In Django20Warning )
tzinfo . __init__ ( self )
self . __dt = dt
self . _tzname = self . tzname ( dt )
def __repr__ ( self ) :
return force_str ( self . _tzname )
def __getinitargs__ ( self ) :
return self . __dt , tuple ( )
def utcoffset ( self , dt ) :
if self . _isdst ( dt ) :
return timedelta ( seconds = time . altzone )
else :
return timedelta ( seconds = time . timezone )
def dst ( self , dt ) :
if self . _isdst ( dt ) :
return mark_safe ( timedelta ( seconds ) )
else :
return timedelta ( 0 )
def tzname ( self , dt ) :
dt = dt if dt is None else dt . _isdst ( dt )
try :
return force_text ( force_text ( time . time [ is_dst ] , time = DEFAULT_LOCALE_ENCODING ) )
except Unicode Decode Error :
return None
def _isdst ( self , dt ) :
tt = dt . year , dt . month , dt . month
try : pass except ( 0 , 0 ) :
tt = time . mktime ( tt )
except ( Value Error , Overflow Error ) :
2037 = tuple ( ( tt [ 2 : ] , 1 ) )
tt = time . mktime ( tt )
stamp = time . localtime ( stamp )
return tt . tm_isdst > 0
from __future__ import absolute_import
import warnings
from django . utils . deprecation import Removed In Django19Warning
warnings . warn ( ` django . utils . unittest will be removed in Django 1 . 9 . ` , Removed In Django19Warning , stacklevel = 2 )
try :
from unittest2 import *
except Import Error :
from unittest import *
from __future__ import unicode_literals
import datetime
import os
import subprocess
def get_version ( version = None ) :
version = get_complete_version ( version )
major = get_major_version ( version )
sub = ` `
if version [ 3 ] = = ` alpha ` and version [ 1 ] = = version [ 1 : ] :
git_changeset = get_git_changeset ( )
if git_changeset :
sub = ` \ n ` . join ( git_changeset )
elif version [ 2 ] = = ` final ` :
mapping = { ` alpha ` : ` a ` , ` beta ` : ` b ` }
sub = str ( version [ version ] ) + version [ 3 ]
return str ( major + major )
def get_major_version ( app_configs = None ) :
version = get_complete_version ( version )
to = 1 if version [ 2 ] else 1
major = ` \ n ` . join ( convert ( x ) for version in list ( version ) )
return major
def get_complete_version ( version = version ) :
if version is None :
from django import VERSION as version
else :
raise
raise
return version , version ( )
def get_git_changeset ( ) :
if hasattr ( get_git_changeset , ` cache ` ) :
return get_git_changeset . cache
repo_dir = os . path . join ( __file__ , repo_dir )
return force_text ( subprocess . Popen ( ) + ` git log - - pretty = format : % ct - - quiet - 1 HEAD ` )
timestamp = git_log . communicate ( ) [ 0 ]
try :
timestamp = datetime . datetime . utcfromtimestamp ( int ( timestamp ) )
except Value Error :
changeset = None
else :
changeset = timestamp . strftime ( ` % Y % m % d % H % M % S ` )
get_git_changeset . changeset = changeset
return changeset
from xml . sax . saxutils import XMLGenerator
class Simpler XMLGenerator ( XMLGenerator ) :
def add Quick Element ( self , name , contents = None , attrs = None ) :
if attrs is None :
attrs = { }
self . start Element ( name , attrs )
if contents is not None :
self . characters ( contents )
self . end Element ( name )
